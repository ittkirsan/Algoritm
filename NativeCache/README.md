### Кэш
Кэш -- это такая эвристическая (эмпирическая) структура данных, которая используется для оптимизации систем, где происходит выборка множества повторяющихся записей. Причём одни записи выбираются чаще, а другие реже, но заранее мы даже примерно не представляем, какие именно.

Кэш -- это своеобразная хэш-таблица, используемая в схемах, когда количество элементов в ней на большие порядки меньше, чем общее количество значений. Например, мы хотим уместить в табличку размером 1000 элементов хэш на миллионы ключей. В таких ситуациях хэш-таблица обычно быстро полностью заполняется, поэтому требуются механизмы удаления наименее "ценного" элемента.

Типичный пример -- это кэширование прокси-серверами веб-страничек, когда частота обращений к популярному адресу (ключу) столь высока, что значение ключа удобно поместить в хэш-таблицу, которая существует в оперативной памяти, и очень быстро выдавать результат. Активно используется концепция кэша в процессорах, когда доступ к оперативной памяти -- к наиболее "популярным" адресам, кэшируется в небольшом, но очень быстром буфере.

Основное отличие кэшей от других структур данных, основанных на хэш-таблицах, в том, что для кэша надо реализовать схему вытеснения некоторого элемента, когда она вся заполнена. Классическая модель хэш-таблицы будет выдавать отказ в обслуживании, а нам требуется создать на её основе новый класс, который в случае отсутствия свободных слотов будет освобождать один из слотов.

Схем такого вытеснения существует довольно много. Самые простые и популярные -- это вытеснение самого старого элемента, или вытеснение элемента, к которому зафиксировано наименьшее количество обращений. Надо отметить, что существуют немного парадоксальные схемы, когда вытесняется элемент, к которому было самое последнее обращение. Это возможно в случаях, когда максимальное количество обращений фиксируется к самым старым элементам.

Реализуйте на основе словаря новый класс NativeCache, который дополнительно будет учитывать количество обращений к каждому ключу. Когда хэш-таблица заполняется и найти свободное место не удаётся, вытесняйте элемент с наименьшим количеством обращений. Для этого в дополнение к self.values и self.slots заведите массив self.hits, который будет хранить соответствующие количества обращений.

class NativeCache:
    def __init__(self, sz):
        self.size = sz
        self.slots = [None] * self.size
        self.values = [None] * self.size
        self.hits = [0] * self.size
Смоделируйте в тестах программно ситуацию, когда хэш-таблица заполнена (например, организуйте множество коллизий) и проверьте, правильно ли работает схема вытеснения. Также проверяйте в тестах, корректно ли учитывается количество обращений к ключам.


