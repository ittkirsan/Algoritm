### Ассоциативный массив
Хэш-таблицы хоть и реализованы в большинстве языков программирования, в стандартных библиотеках, однако напрямую используются редко, так как сами по себе не очень полезны. Однако существует такая очень популярная структура данных, как ассоциативный массив (или словарь), когда мы храним данные в формате ключ - значение. Такой массив отличается от обычного тем, что в качестве индексов выступают не целые числа, а произвольные значения (например, строки). Вот тут мы и находим точку пересечения с хэш-таблицами.

Стандартный словарь Python позволяет записать в переменную набор пар ключ-значение:

my_dict = {"key1": "значение 1", "ключ 23": 512}
и в дальнейшем получать нужное значение, указав ключ в качестве индекса:

my_dict["ключ 23"] # 512
Можно изменять значения в словаре:

my_dict["ключ 23"] = 1024
Для реализации ассоциативного массива воспользуемся хэш-таблицей, реализованной в предыдущем занятии. По сути, требуется лишь дополнить ее вторым массивом self.values -- в дополнение к массиву self.slots, который будет хранить ключи.
self.values по размеру будет таким же, как и self.slots, а записываются в него значения, соответствующие ключу слота (с таким же индексом).

Главное отличие ассоциативного массива от хэш-таблицы в том, что он обычно не ограничен каким-то фиксированным размером (количеством ключей), и либо исходно под конкретную задачу создаётся с гарантированным запасом по размеру, либо сочетает возможности хэш-таблицы и динамического массива.

Если по каким-то причинам реализация с хэш-функциями не подходит (например, возникает слишком много коллизий), то для реализации словаря вполне можно использовать упорядоченный массив фиксированного размера, который хранит, например, объекты с двумя полями ключ и значение.
Другой вариант -- использовать для реализации словаря двоичное сбалансированное дерево, где поиск ключей происходит очень эффективно (все важные виды поиска проходим на курсах по деревьям графам и сортировкам). Но сама реализация будет сложнее, она подразумевает работу с указателями и динамическим выделением памяти, а изменение структуры дерева (добавление новых узлов и балансировка) может требовать дополнительных накладных ресурсов, если, например, счёт идёт на миллионы элементов.

### Реализуйте три метода:

- put(key, value) - сохранение внутри класса ассоциативного массива пары ключ-значение по описанной выше схеме;

- is_key(key) - проверка, имеется ли в слотах такой ключ;

- get(key) - поиск и извлечение значения по ключу, или None, если ключ не найден.

4. Сделайте тесты, проверяющие, как работают put(), is_key() и get():
- добавление значения по новому ключу и добавление значения по уже существующему ключу с проверками что записалось, проверка присутствующего и отсутствующего ключей, извлечение значения по существующему и отсутствующему ключу.