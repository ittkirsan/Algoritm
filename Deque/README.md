### Двусторонняя очередь (deque)
Это такое своеобразное расширение очереди и стека, у которого два входа (голова и хвост), и они же одновременно и выходы. То есть строгого правила, кто в каком порядке выходит, тут нету.

Таким образом нам требуются не два, а четыре основных метода: добавление/удаление объекта в голову addFront/removeFront , и добавление/удаление объекта в хвост addTail/removeTail. При этом сама внутренняя структура сохраняет принцип очереди, конечно. Поэтому при реализации deque на Python с помощью стандартного списка мы получим немного парадоксальный результат в плане эффективности.

deq = Deque()
deq.addFront("f1")
deq.addTail("t1")
deq.addFront("f2")
deq.addTail("t2")
while deq.size() > 0:
    print(deq.removeFront())
    print(deq.removeTail())
Проблема здесь в том, что мера сложности нашей реализации сильно зависит от того, что в нашем внутреннем списке мы выберем головой, а что хвостом.

### Задания.

7.1. Почему и как будет различаться мера сложности для addHead/removeHead и addTail/removeTail?

7.2. Напишите функцию, которая с помощью deque проверяет, является ли некоторая строка палиндромом (читается одинаково слева направо и справа налево).

7.3. Добавьте для каждого из четырёх вышеупомянутых методов тесты: проверяйте изменившуюся длину очереди и наличие или отстутствие в ней добавляемого/удаляемого элемента.