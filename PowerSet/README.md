### Множества
В прошлый раз мы рассмотрели, как хэш-таблицы расширить до концепции словарей. Однако существует одно полезное применение хэш-таблиц самих по себе -- это так называемые множества.

В Python множества реализованы как тип данных set. Это просто неупорядоченное хранилище данных -- мы даже не можем обратиться к нему для извлечения значения по ключу или индексу. Его ключевая особенность -- каждое значение хранится в нём в единичном экземпляре.

Мы можем определить множество из нескольких значений так:

a = {1024, '512', 3.14}
Следующая запись хоть и считается корректной, однако в переменной a всё равно окажется лишь три значения:

a = {1024, '512', 3.14, 3.14} # {1024, '512', 3.14}
Поэтому в частности множества удобно использовать для исключения дублирующих значений.

Главный плюс множества -- это высокая скорость проверки, принадлежит ли элемент множеству, её сложность O(1).

Принципиальный момент -- когда будете создавать свои классы подобной направленности, всегда придерживайтесь принципа, что все они должны работать с одним типом данных. Условно говоря, если вы создаёте класс (тип) String, то подразумеваете, что его методы получают данные строкового типа и возвращают тоже данные строкового типа. То есть мы по сути описываем набор операций над одним типом, которые и возвращают данные тоже этого типа (формально говоря, это такая алгебра с замыканием -- замыкание значений нашего типа относительно заданного набора операций над этим типом). Целое плюс целое будет целое, и целое делённое на целое тоже ожидаем целое.

Смысл в этом подходе большой и глубокий. В данном случае intersection(), union(), difference() замкнуты относительно типа PowerSet. Странно было бы объединить два множества, а получить в результате список, а не множество, однако такая наивная ошибка не редкость. Избежать этого помогает принцип, когда в общем случае мы задаём операции над некоторым типом (классом) Т и ожидаем, что например сложение или вычитание множеств тоже дадут в результате множество (что естественно).

Создайте реализующий множество класс PowerSet. Его в принципе можно выполнить на основе класса HashTable, где достаточно будет не допускать добавление уже существующего в множестве значения (изменить оригинальный метод put()). Однако здесь проявляется стандартная для Python проблема, что такую структуру данных эффективно реализовать трудно на самом Python, который компилируется не в машинный код, а в промежуточный, и фактически интерпретируется, поэтому и работает медленно.
Поэтому для внутреннего хранения множества можно взять даже стандартный список (только не стандартное множество, иначе получится "масло масляное"), и просто добавлять и удалять элементы в нём.
В данном случае задача прежде всего в правильной реализации публичных методов множества, но при этом код должен достаточно быстро работать, за 1-2 секунды, с множествами из 20,000 элементов.

В общем случае, если коллизий немного и разрешаются они быстро, то лучше всего подходит хэш-таблица. Если добавления/удаления редки, то хорошо подойдёт упорядоченный список или двоичное дерево.
Вы можете в данном учебном занятии использовать даже стандартный словарь или список (только не стандартное множество set, конечно :), главное чтобы корректно работал публичный интерфейс класса.

### Реализуйте следующие типичные для множества методы:

- remove(значение) -- удаление элемента из множества;

- intersection(), в качестве параметра выступает другое множество, а возвращается пересечение этих множеств (множество, в котором есть только те элементы, которые имеются в каждом из множеств);

- union(), в качестве параметра выступает другое множество, а возвращается объединение этих множеств (множество, в котором есть все элементы из каждого множества);

- difference(), в качестве параметра выступает другое множество, а возвращается подмножество текущего множества из таких элементов, которые не входят в множество-параметр;

- issubset(), в качестве параметра выступает другое множество, и проверяется, входят ли все его элементы в текущее множество (будет ли множество-параметр подмножеством текущего множества).

3. Добавьте тесты, которые проверяют:
- возможность добавления отсутствующего элемента и невозможность добавления присутствующего в множестве элемента с помощью put();
- удаление элемента с помощью remove();
- пересечение множеств intersection(), чтобы в результате получались как пустое, так и непустое множества;
- объединение union(), когда оба параметра непустые, и когда один из параметров -- пустое множество;
- разница difference(), чтобы в результате получались как пустое, так и непустое множества;
- подмножество issubset() -- рассмотрите три случая (все элементы параметра входят в текущее множество, все элементы текущего множества входят в параметр, не все элементы параметра входят в текущее множество);
- быстродействие (операции над множествами из десятков тысяч элементов укладываются в пару секунд).