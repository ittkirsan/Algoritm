
## git Задания.
2.1. Добавьте в класс LinkedList2 метод поиска первого узла по его значению.
find(val)
2.2. Добавьте в класс LinkedList2 метод поиска всех узлов по конкретному значению (возвращается список найденных узлов).

find_all(val)
2.3. Добавьте в класс LinkedList2 метод удаления одного узла по его значению.
delete(val, all=False)
где флажок all=False по умолчанию -- удаляем только первый нашедшийся элемент.

2.4. Дополните этот метод удалением всех узлов по конкретному значению (флажок all=True).

2.5. Добавьте в класс LinkedList2 метод вставки узла после заданного узла.
insert(afterNode, newNode)
Если afterNode = None и список пустой, добавьте новый элемент первым в списке.
Если afterNode = None и список непустой, добавьте новый элемент последним в списке.

2.6. Добавьте в класс LinkedList2 метод вставки узла самым первым элементом.
add_in_head(newNode)
2.7. Добавьте в класс LinkedList2 метод очистки всего содержимого (создание пустого списка) -- clean()

2.8. Добавьте в класс LinkedList2 метод вычисления текущей длины списка -- len()

2.9. Напишите проверочные тесты для каждого из предыдущих заданий.

* 2.10. Существует интересный финт, обсуждаемый на курсе Стэнфордского университета CS106B -- фиктивный/пустой (dummy) узел. Пока нам при любых модификациях списка (добавление/удаление узла) приходится рассматривать три отдельные ситуации: работа с серединой списка, с его головой и с его хвостом. Фиктивный узел позволяет избавиться от этих краевых ситуаций, оставив только по одной универсальной операции на добавление и удаление. Идея в том, что мы добавляем в список два искусственных узла -- голову и хвост, которые пользователю класса не видны (они отличаются от видимых узлов, например, булевым флажком, а лучше всего это делать через наследование и перегрузку). Теперь, добавляя или удаляя узлы, мы всегда будем уверены, что у каждого из них имеется и предыдущий узел, и последующий, и от дополнительных проверок и модификаций полей head и tail можно избавиться.